#!/usr/bin/env python3

import sys
import numpy as np
import matplotlib.pyplot as plt
import argparse
import math # For subplot grid calculation

parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)
parser.add_argument("-i", "--input", type=str, default="-", help="Name of the input CSV file ('-' for stdin)")
parser.add_argument("--title", type=str, default="Magnetization Evolution", help="Base title for plots")
parser.add_argument("--output", type=str, help="Base filename for saving plots (e.g., 'run'. Will append '_start_i.png')")
parser.add_argument("--max-plots", type=int, default=9, help="Maximum number of starting patterns to plot (to avoid too many windows)")


arguments = parser.parse_args()

# --- Load Data ---
filename = arguments.input if arguments.input != '-' else sys.stdin
try:
    # Load data, skipping the header row generated by simulate.py
    data = np.loadtxt(filename, delimiter=",", skiprows=1)
except Exception as e:
    print(f"Error loading data from {filename}: {e}", file=sys.stderr)
    sys.exit(1)

# --- Determine dimensions ---
num_sweeps = data.shape[0]
total_columns = data.shape[1]
# Infer p (number of patterns) - total columns should be p*p
p = int(math.sqrt(total_columns))
if p * p != total_columns:
    print(f"Error: Number of columns ({total_columns}) is not a perfect square. Cannot infer 'p'.", file=sys.stderr)
    sys.exit(1)

print(f"Data loaded: {num_sweeps} sweeps, p={p} patterns inferred.")

# Limit the number of plots generated interactively
plots_to_show = min(p, arguments.max_plots)
if plots_to_show < p:
    print(f"Warning: Plotting only the first {plots_to_show} starting patterns (--max-plots).")


# --- Create Time Axis ---
# Assuming each row corresponds to one sweep, starting from sweep 1
sweeps_axis = np.arange(1, num_sweeps + 1)

# --- Generate Plots ---
# Determine subplot grid layout (optional, could just create separate figures)
# cols = math.ceil(math.sqrt(plots_to_show))
# rows = math.ceil(plots_to_show / cols)
# fig, axes = plt.subplots(rows, cols, figsize=(5 * cols, 4 * rows), squeeze=False)
# axes = axes.flatten() # Flatten to easily index

plt.style.use('seaborn-v0_8-darkgrid') # Use a nice style

# Create separate figures for each starting pattern (simpler than subplots)
for start_pattern_idx in range(plots_to_show): # Iterate through starting patterns to plot
    fig_i, ax_i = plt.subplots(figsize=(9, 5)) # Create a new figure and axes

    print(f"Plotting for simulation starting from pattern {start_pattern_idx + 1}...")

    # Extract the block of p columns corresponding to this starting pattern
    start_col = start_pattern_idx * p
    end_col = start_col + p
    evolution_data = data[:, start_col:end_col] # Shape (sweeps, p)

    # Define colors for the measured patterns
    colors = plt.cm.viridis(np.linspace(0, 0.9, p)) # Use colormap

    # Plot the evolution of overlap with each pattern
    for measured_pattern_idx in range(p):
        magnetization = evolution_data[:, measured_pattern_idx]
        label_str = f"$m_{{{measured_pattern_idx + 1}}}$" # LaTeX style label m_1, m_2 etc.

        # Highlight the line corresponding to the starting pattern
        if measured_pattern_idx == start_pattern_idx:
            ax_i.plot(sweeps_axis, magnetization, label=label_str, color=colors[measured_pattern_idx], linewidth=2.5, zorder=10)
        else:
            ax_i.plot(sweeps_axis, magnetization, label=label_str, color=colors[measured_pattern_idx], linewidth=1.5, alpha=0.8)

    # --- Add plot labels and styling ---
    ax_i.set_title(f"{arguments.title} (Started near Pattern {start_pattern_idx + 1})")
    ax_i.set_xlabel("Number of Sweeps")
    ax_i.set_ylabel("Magnetization (Overlap)")
    ax_i.grid(True, linestyle='--', alpha=0.7)
    ax_i.legend(loc='center left', bbox_to_anchor=(1, 0.5), fontsize='small') # Legend outside plot
    ax_i.set_ylim(min(np.min(data), -0.1), max(np.max(data), 1.1) if data.size > 0 else 1.1) # Adjust y-axis limits
    ax_i.set_xlim(left=0) # Start x-axis at 0

    plt.tight_layout(rect=[0, 0, 0.9, 1]) # Adjust layout to make space for legend

    # --- Save or Show Plot ---
    if arguments.output:
        output_filename = f"{arguments.output}_start_{start_pattern_idx + 1}.png"
        try:
            plt.savefig(output_filename)
            print(f"  Plot saved to {output_filename}")
        except Exception as e:
             print(f"  Error saving plot {output_filename}: {e}", file=sys.stderr)
        plt.close(fig_i) # Close the figure after saving to prevent display overload
    # else:
    #     plt.show() # Show plot interactively - might open many windows!

# If not saving, show all plots at the end (can be overwhelming)
if not arguments.output:
    plt.show()